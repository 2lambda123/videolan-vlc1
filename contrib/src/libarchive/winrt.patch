From 2594486c32fd71ca63d0eea10b7266034f703eb0 Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robux4@ycbcr.xyz>
Date: Fri, 27 Mar 2020 16:25:36 +0100
Subject: [PATCH] WIP fix compilation for Universal Windows

---
 libarchive/archive_digest.c                   | 50 +++++++++++-
 libarchive/archive_digest_private.h           |  9 +++
 libarchive/archive_random.c                   |  7 ++
 libarchive/archive_read_disk_windows.c        | 80 +++++++++++++++++++
 .../archive_read_support_filter_bzip2.c       |  4 +
 .../archive_read_support_filter_grzip.c       |  4 +
 .../archive_read_support_filter_lrzip.c       |  4 +
 libarchive/archive_read_support_filter_lz4.c  |  4 +
 libarchive/archive_read_support_filter_lzop.c |  4 +
 .../archive_read_support_filter_program.c     | 12 ++-
 libarchive/archive_read_support_filter_xz.c   | 12 +++
 libarchive/archive_read_support_filter_zstd.c |  4 +
 .../archive_read_support_format_mtree.c       | 10 +++
 libarchive/archive_string.c                   |  2 +-
 libarchive/archive_util.c                     |  9 ++-
 libarchive/archive_windows.c                  | 31 ++++++-
 libarchive/archive_windows.h                  |  4 +
 libarchive/archive_write_disk_windows.c       | 78 ++++++++++++++++++
 libarchive/filter_fork_windows.c              |  8 ++
 19 files changed, 327 insertions(+), 9 deletions(-)

diff --git a/libarchive/archive_digest.c b/libarchive/archive_digest.c
index a7bd5f02..02dd27ee 100644
--- a/libarchive/archive_digest.c
+++ b/libarchive/archive_digest.c
@@ -48,6 +48,19 @@
 /*
  * Initialize a Message digest.
  */
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+static int
+win_crypto_init(Digest_CTX *ctx, const WCHAR *algo)
+{
+	ctx->valid = 0;
+
+	BCryptOpenAlgorithmProvider(&ctx->algo_handle, algo, NULL, 0);
+	BCryptCreateHash(ctx->algo_handle, &ctx->hash, NULL, 0, NULL, 0, 0);
+
+	ctx->valid = 1;
+	return (ARCHIVE_OK);
+}
+#else
 static int
 win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
 {
@@ -70,6 +83,7 @@ win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
 	ctx->valid = 1;
 	return (ARCHIVE_OK);
 }
+#endif
 
 /*
  * Update a Message digest.
@@ -81,23 +95,35 @@ win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
 	if (!ctx->valid)
 		return (ARCHIVE_FAILED);
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+	BCryptHashData(ctx->hash,
+		      (PUCHAR) buf,
+		      len, 0);
+#else
 	CryptHashData(ctx->hash,
 		      (unsigned char *)(uintptr_t)buf,
 		      (DWORD)len, 0);
+#endif
 	return (ARCHIVE_OK);
 }
 
 static int
 win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
 {
-	DWORD siglen = (DWORD)bufsize;
-
 	if (!ctx->valid)
 		return (ARCHIVE_FAILED);
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+	BCryptFinishHash(ctx->hash, buf, (ULONG)bufsize, 0);
+	BCryptDestroyHash(ctx->hash);
+	BCryptCloseAlgorithmProvider(ctx->algo_handle, 0);
+#else
+	DWORD siglen = (DWORD)bufsize;
+
 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
 	CryptDestroyHash(ctx->hash);
 	CryptReleaseContext(ctx->cryptProv, 0);
+#endif
 	ctx->valid = 0;
 	return (ARCHIVE_OK);
 }
@@ -276,7 +302,11 @@ __archive_md5final(archive_md5_ctx *ctx, void *md)
 static int
 __archive_md5init(archive_md5_ctx *ctx)
 {
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+  return (win_crypto_init(ctx, BCRYPT_MD5_ALGORITHM));
+#else
   return (win_crypto_init(ctx, CALG_MD5));
+#endif
 }
 
 static int
@@ -659,7 +689,11 @@ __archive_sha1final(archive_sha1_ctx *ctx, void *md)
 static int
 __archive_sha1init(archive_sha1_ctx *ctx)
 {
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+  return (win_crypto_init(ctx, BCRYPT_SHA1_ALGORITHM));
+#else
   return (win_crypto_init(ctx, CALG_SHA1));
+#endif
 }
 
 static int
@@ -919,7 +953,11 @@ __archive_sha256final(archive_sha256_ctx *ctx, void *md)
 static int
 __archive_sha256init(archive_sha256_ctx *ctx)
 {
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+  return (win_crypto_init(ctx, BCRYPT_SHA256_ALGORITHM));
+#else
   return (win_crypto_init(ctx, CALG_SHA_256));
+#endif
 }
 
 static int
@@ -1155,7 +1193,11 @@ __archive_sha384final(archive_sha384_ctx *ctx, void *md)
 static int
 __archive_sha384init(archive_sha384_ctx *ctx)
 {
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+  return (win_crypto_init(ctx, BCRYPT_SHA384_ALGORITHM));
+#else
   return (win_crypto_init(ctx, CALG_SHA_384));
+#endif
 }
 
 static int
@@ -1415,7 +1457,11 @@ __archive_sha512final(archive_sha512_ctx *ctx, void *md)
 static int
 __archive_sha512init(archive_sha512_ctx *ctx)
 {
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+  return (win_crypto_init(ctx, BCRYPT_SHA512_ALGORITHM));
+#else
   return (win_crypto_init(ctx, CALG_SHA_512));
+#endif
 }
 
 static int
diff --git a/libarchive/archive_digest_private.h b/libarchive/archive_digest_private.h
index 9b3bd662..8082059c 100644
--- a/libarchive/archive_digest_private.h
+++ b/libarchive/archive_digest_private.h
@@ -165,11 +165,20 @@
   defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
   defined(ARCHIVE_CRYPTO_SHA512_WIN)
 #include <windows.h>
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+#include <bcrypt.h>
+#else
 #include <wincrypt.h>
+#endif
 typedef struct {
   int   valid;
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+  BCRYPT_ALG_HANDLE  algo_handle;
+  BCRYPT_HASH_HANDLE hash;
+#else
   HCRYPTPROV  cryptProv;
   HCRYPTHASH  hash;
+#endif
 } Digest_CTX;
 #endif
 
diff --git a/libarchive/archive_random.c b/libarchive/archive_random.c
index 9d1aa493..e63ffbfa 100644
--- a/libarchive/archive_random.c
+++ b/libarchive/archive_random.c
@@ -75,6 +75,12 @@ int
 archive_random(void *buf, size_t nbytes)
 {
 #if defined(_WIN32) && !defined(__CYGWIN__)
+# if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+	BCRYPT_ALG_HANDLE algo_handle;
+	BCryptOpenAlgorithmProvider(&algo_handle, BCRYPT_RNG_ALGORITHM, NULL, 0);
+	BCryptGenRandom(algo_handle, buf, nbytes, 0);
+	BCryptCloseAlgorithmProvider(algo_handle, 0);
+# else
 	HCRYPTPROV hProv;
 	BOOL success;
 
@@ -92,6 +98,7 @@ archive_random(void *buf, size_t nbytes)
 	}
 	/* TODO: Does this case really happen? */
 	return ARCHIVE_FAILED;
+# endif
 #else
 	arc4random_buf(buf, nbytes);
 	return ARCHIVE_OK;
diff --git a/libarchive/archive_read_disk_windows.c b/libarchive/archive_read_disk_windows.c
index ea32e2aa..7dd2e8a8 100644
--- a/libarchive/archive_read_disk_windows.c
+++ b/libarchive/archive_read_disk_windows.c
@@ -418,8 +418,19 @@ la_linkname_from_pathw(const wchar_t *path, wchar_t **outbuf, int *linktype)
 	    FILE_FLAG_OPEN_REPARSE_POINT;
 	int ret;
 
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+	CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+	createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+	createExParams.dwFileAttributes = 0;
+	createExParams.dwFileFlags = flag;
+	createExParams.dwSecurityQosFlags = 0;
+	createExParams.lpSecurityAttributes = NULL;
+	createExParams.hTemplateFile = NULL;
+	h = CreateFile2(path, 0, FILE_SHARE_READ, OPEN_EXISTING, &createExParams);
+#else
 	h = CreateFileW(path, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, flag,
 	    NULL);
+#endif
 	if (h == INVALID_HANDLE_VALUE) {
 		la_dosmaperr(GetLastError());
 		return (-1);
@@ -707,7 +718,11 @@ start_next_async_read(struct archive_read_disk *a, struct tree *t)
 	if (olp->buff == NULL) {
 		void *p;
 		size_t s = (size_t)align_num_per_sector(t, READ_BUFFER_SIZE);
+#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)
 		p = VirtualAlloc(NULL, s, MEM_COMMIT, PAGE_READWRITE);
+#else /* !WINAPI_PARTITION_DESKTOP */
+		p = VirtualAllocFromApp(NULL, s, MEM_COMMIT, PAGE_READWRITE);
+#endif /* !WINAPI_PARTITION_DESKTOP */
 		if (p == NULL) {
 			archive_set_error(&a->archive, ENOMEM,
 			    "Couldn't allocate memory");
@@ -1072,8 +1087,20 @@ next_entry(struct archive_read_disk *a, struct tree *t,
 			flags |= FILE_FLAG_NO_BUFFERING;
 		else
 			flags |= FILE_FLAG_SEQUENTIAL_SCAN;
+#if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+		CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+		createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+		createExParams.dwFileAttributes = 0;
+		createExParams.dwFileFlags = flags;
+		createExParams.dwSecurityQosFlags = 0;
+		createExParams.lpSecurityAttributes = NULL;
+		createExParams.hTemplateFile = NULL;
+		t->entry_fh = CreateFile2(tree_current_access_path(t),
+			GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, &createExParams);
+#else
 		t->entry_fh = CreateFileW(tree_current_access_path(t),
 		    GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, flags, NULL);
+#endif
 		if (t->entry_fh == INVALID_HANDLE_VALUE) {
 			la_dosmaperr(GetLastError());
 			archive_set_error(&a->archive, errno,
@@ -1506,7 +1533,12 @@ setup_current_filesystem(struct archive_read_disk *a)
 
 	t->current_filesystem->synthetic = -1;/* Not supported */
 	path = safe_path_for_statfs(t);
+#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)
 	if (!GetVolumePathNameW(path, vol, sizeof(vol)/sizeof(vol[0]))) {
+#else /* !WINAPI_PARTITION_DESKTOP */
+	DWORD MaximumComponentLength, FileSystemFlags;
+	if (!GetVolumeInformationW(path, vol, sizeof(vol)/sizeof(vol[0]), NULL, &MaximumComponentLength, &FileSystemFlags, NULL, 0)) {
+#endif
 		free(path);
 		t->current_filesystem->remote = -1;
 		t->current_filesystem->bytesPerSector = 0;
@@ -1557,8 +1589,20 @@ close_and_restore_time(HANDLE h, struct tree *t, struct restore_time *rt)
 	if ((t->flags & needsRestoreTimes) == 0)
 		return (r);
 
+#if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+	CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+	createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+	createExParams.dwFileAttributes = FILE_SHARE_READ;
+	createExParams.dwFileFlags = FILE_FLAG_BACKUP_SEMANTICS;
+	createExParams.dwSecurityQosFlags = 0;
+	createExParams.lpSecurityAttributes = NULL;
+	createExParams.hTemplateFile = NULL;
+	handle = CreateFile2(rt->full_path, FILE_WRITE_ATTRIBUTES,
+		    0, OPEN_EXISTING, &createExParams);
+#else
 	handle = CreateFileW(rt->full_path, FILE_WRITE_ATTRIBUTES,
 		    0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
+#endif
 	if (handle == INVALID_HANDLE_VALUE) {
 		errno = EINVAL;
 		return (-1);
@@ -2046,8 +2090,20 @@ tree_current_file_information(struct tree *t, BY_HANDLE_FILE_INFORMATION *st,
 	
 	if (sim_lstat && tree_current_is_physical_link(t))
 		flag |= FILE_FLAG_OPEN_REPARSE_POINT;
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+	CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+	createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+	createExParams.dwFileAttributes = 0;
+	createExParams.dwFileFlags = flag;
+	createExParams.dwSecurityQosFlags = 0;
+	createExParams.lpSecurityAttributes = NULL;
+	createExParams.hTemplateFile = NULL;
+	h = CreateFile2(tree_current_access_path(t), 0, FILE_SHARE_READ,
+	    OPEN_EXISTING, &createExParams);
+#else
 	h = CreateFileW(tree_current_access_path(t), 0, FILE_SHARE_READ, NULL,
 	    OPEN_EXISTING, flag, NULL);
+#endif
 	if (h == INVALID_HANDLE_VALUE) {
 		la_dosmaperr(GetLastError());
 		t->tree_errno = errno;
@@ -2275,8 +2331,20 @@ archive_read_disk_entry_from_file(struct archive *_a,
 			} else
 				desiredAccess = GENERIC_READ;
 
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+			CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+			createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+			createExParams.dwFileAttributes = 0;
+			createExParams.dwFileFlags = flag;
+			createExParams.dwSecurityQosFlags = 0;
+			createExParams.lpSecurityAttributes = NULL;
+			createExParams.hTemplateFile = NULL;
+			h = CreateFile2(path, desiredAccess, FILE_SHARE_READ,
+			    OPEN_EXISTING, &createExParams);
+#else
 			h = CreateFileW(path, desiredAccess, FILE_SHARE_READ, NULL,
 			    OPEN_EXISTING, flag, NULL);
+#endif
 			if (h == INVALID_HANDLE_VALUE) {
 				la_dosmaperr(GetLastError());
 				archive_set_error(&a->archive, errno,
@@ -2337,8 +2405,20 @@ archive_read_disk_entry_from_file(struct archive *_a,
 		if (fd >= 0) {
 			h = (HANDLE)_get_osfhandle(fd);
 		} else {
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+			CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+			createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+			createExParams.dwFileAttributes = 0;
+			createExParams.dwFileFlags = FILE_FLAG_BACKUP_SEMANTICS;
+			createExParams.dwSecurityQosFlags = 0;
+			createExParams.lpSecurityAttributes = NULL;
+			createExParams.hTemplateFile = NULL;
+			h = CreateFile2(path, GENERIC_READ, FILE_SHARE_READ,
+			    OPEN_EXISTING, &createExParams);
+#else
 			h = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ, NULL,
 			    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
+#endif
 			if (h == INVALID_HANDLE_VALUE) {
 				la_dosmaperr(GetLastError());
 				archive_set_error(&a->archive, errno,
diff --git a/libarchive/archive_read_support_filter_bzip2.c b/libarchive/archive_read_support_filter_bzip2.c
index 793d605c..57a84eba 100644
--- a/libarchive/archive_read_support_filter_bzip2.c
+++ b/libarchive/archive_read_support_filter_bzip2.c
@@ -159,6 +159,7 @@ bzip2_reader_bid(struct archive_read_filter_bidder *self, struct archive_read_fi
 static int
 bzip2_reader_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "bzip2 -d");
@@ -168,6 +169,9 @@ bzip2_reader_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_BZIP2;
 	self->name = "bzip2";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
 
 
diff --git a/libarchive/archive_read_support_filter_grzip.c b/libarchive/archive_read_support_filter_grzip.c
index d4d1737c..7660b392 100644
--- a/libarchive/archive_read_support_filter_grzip.c
+++ b/libarchive/archive_read_support_filter_grzip.c
@@ -100,6 +100,7 @@ grzip_bidder_bid(struct archive_read_filter_bidder *self,
 static int
 grzip_bidder_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "grzip -d");
@@ -109,4 +110,7 @@ grzip_bidder_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_GRZIP;
 	self->name = "grzip";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
diff --git a/libarchive/archive_read_support_filter_lrzip.c b/libarchive/archive_read_support_filter_lrzip.c
index a2389894..562e37e0 100644
--- a/libarchive/archive_read_support_filter_lrzip.c
+++ b/libarchive/archive_read_support_filter_lrzip.c
@@ -110,6 +110,7 @@ lrzip_bidder_bid(struct archive_read_filter_bidder *self,
 static int
 lrzip_bidder_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "lrzip -d -q");
@@ -119,4 +120,7 @@ lrzip_bidder_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_LRZIP;
 	self->name = "lrzip";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
diff --git a/libarchive/archive_read_support_filter_lz4.c b/libarchive/archive_read_support_filter_lz4.c
index ae0b0800..3f7fc14e 100644
--- a/libarchive/archive_read_support_filter_lz4.c
+++ b/libarchive/archive_read_support_filter_lz4.c
@@ -194,6 +194,7 @@ lz4_reader_bid(struct archive_read_filter_bidder *self,
 static int
 lz4_reader_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "lz4 -d -q");
@@ -203,6 +204,9 @@ lz4_reader_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_LZ4;
 	self->name = "lz4";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
 
 
diff --git a/libarchive/archive_read_support_filter_lzop.c b/libarchive/archive_read_support_filter_lzop.c
index afd2d4d0..7dd80c0b 100644
--- a/libarchive/archive_read_support_filter_lzop.c
+++ b/libarchive/archive_read_support_filter_lzop.c
@@ -158,6 +158,7 @@ lzop_bidder_bid(struct archive_read_filter_bidder *self,
 static int
 lzop_bidder_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "lzop -d");
@@ -167,6 +168,9 @@ lzop_bidder_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_LZOP;
 	self->name = "lzop";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
 #else
 
diff --git a/libarchive/archive_read_support_filter_program.c b/libarchive/archive_read_support_filter_program.c
index 885b2c20..4015cea2 100644
--- a/libarchive/archive_read_support_filter_program.c
+++ b/libarchive/archive_read_support_filter_program.c
@@ -82,6 +82,8 @@ archive_read_support_filter_program(struct archive *a, const char *cmd)
 	return (archive_read_support_filter_program_signature(a, cmd, NULL, 0));
 }
 
+ #if !defined(_WIN32) || WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+
 /*
  * The bidder object stores the command and the signature to watch for.
  * The 'inhibit' entry here is used to ensure that unchecked filters never
@@ -105,7 +107,7 @@ static void	program_bidder_free(struct archive_read_filter_bidder *);
  */
 struct program_filter {
 	struct archive_string description;
-#if defined(_WIN32) && !defined(__CYGWIN__)
+#if defined(_WIN32) && !defined(__CYGWIN__) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	HANDLE		 child;
 #else
 	pid_t		 child;
@@ -243,7 +245,7 @@ child_stop(struct archive_read_filter *self, struct program_filter *state)
 			state->waitpid_return
 			    = waitpid(state->child, &state->exit_status, 0);
 		} while (state->waitpid_return == -1 && errno == EINTR);
-#if defined(_WIN32) && !defined(__CYGWIN__)
+#if defined(_WIN32) && !defined(__CYGWIN__) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 		CloseHandle(state->child);
 #endif
 		state->child = 0;
@@ -298,7 +300,7 @@ child_read(struct archive_read_filter *self, char *buf, size_t buf_len)
 	struct program_filter *state = self->data;
 	ssize_t ret, requested, avail;
 	const char *p;
-#if defined(_WIN32) && !defined(__CYGWIN__)
+#if defined(_WIN32) && !defined(__CYGWIN__) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	HANDLE handle = (HANDLE)_get_osfhandle(state->child_stdout);
 #endif
 
@@ -306,7 +308,7 @@ child_read(struct archive_read_filter *self, char *buf, size_t buf_len)
 
 	for (;;) {
 		do {
-#if defined(_WIN32) && !defined(__CYGWIN__)
+#if defined(_WIN32) && !defined(__CYGWIN__) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 			/* Avoid infinity wait.
 			 * Note: If there is no data in the pipe, ReadFile()
 			 * called in read() never returns and so we won't
@@ -494,3 +496,5 @@ program_filter_close(struct archive_read_filter *self)
 
 	return (e);
 }
+
+#endif // !_WIN32 || WINAPI_PARTITION_DESKTOP
diff --git a/libarchive/archive_read_support_filter_xz.c b/libarchive/archive_read_support_filter_xz.c
index 32ae0be9..a521548f 100644
--- a/libarchive/archive_read_support_filter_xz.c
+++ b/libarchive/archive_read_support_filter_xz.c
@@ -749,6 +749,7 @@ xz_filter_close(struct archive_read_filter *self)
 static int
 lzma_bidder_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "lzma -d -qq");
@@ -758,11 +759,15 @@ lzma_bidder_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_LZMA;
 	self->name = "lzma";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
 
 static int
 xz_bidder_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "xz -d -qq");
@@ -772,11 +777,15 @@ xz_bidder_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_XZ;
 	self->name = "xz";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
 
 static int
 lzip_bidder_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "lzip -d -q");
@@ -786,6 +795,9 @@ lzip_bidder_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_LZIP;
 	self->name = "lzip";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
 
 #endif /* HAVE_LZMA_H */
diff --git a/libarchive/archive_read_support_filter_zstd.c b/libarchive/archive_read_support_filter_zstd.c
index 39f25f1b..15bec661 100644
--- a/libarchive/archive_read_support_filter_zstd.c
+++ b/libarchive/archive_read_support_filter_zstd.c
@@ -144,6 +144,7 @@ zstd_bidder_bid(struct archive_read_filter_bidder *self,
 static int
 zstd_bidder_init(struct archive_read_filter *self)
 {
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	int r;
 
 	r = __archive_read_program(self, "zstd -d -qq");
@@ -153,6 +154,9 @@ zstd_bidder_init(struct archive_read_filter *self)
 	self->code = ARCHIVE_FILTER_ZSTD;
 	self->name = "zstd";
 	return (r);
+#else
+    return ARCHIVE_FATAL;
+#endif
 }
 
 #else
diff --git a/libarchive/archive_read_support_format_mtree.c b/libarchive/archive_read_support_format_mtree.c
index 4a281632..e398625a 100644
--- a/libarchive/archive_read_support_format_mtree.c
+++ b/libarchive/archive_read_support_format_mtree.c
@@ -58,6 +58,8 @@ __FBSDID("$FreeBSD: head/lib/libarchive/archive_read_support_format_mtree.c 2011
 #include "archive_string.h"
 #include "archive_pack_dev.h"
 
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+
 #ifndef O_BINARY
 #define	O_BINARY 0
 #endif
@@ -2138,3 +2140,11 @@ readline(struct archive_read *a, struct mtree *mtree, char **start,
 		find_off = u - mtree->line.s;
 	}
 }
+
+#else
+int
+archive_read_support_format_mtree(struct archive *_a)
+{
+    return ARCHIVE_OK;
+}
+#endif
diff --git a/libarchive/archive_string.c b/libarchive/archive_string.c
index d7f2c46b..60daeafe 100644
--- a/libarchive/archive_string.c
+++ b/libarchive/archive_string.c
@@ -1323,7 +1323,7 @@ free_sconv_object(struct archive_string_conv *sc)
 	free(sc);
 }
 
-#if defined(_WIN32) && !defined(__CYGWIN__)
+#if defined(_WIN32) && !defined(__CYGWIN__) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 static unsigned
 my_atoi(const char *p)
 {
diff --git a/libarchive/archive_util.c b/libarchive/archive_util.c
index b1582edb..2efff38a 100644
--- a/libarchive/archive_util.c
+++ b/libarchive/archive_util.c
@@ -209,7 +209,7 @@ __archive_errx(int retvalue, const char *msg)
  * Create a temporary file
  */
 #if defined(_WIN32) && !defined(__CYGWIN__)
-
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 /*
  * Do not use Windows tmpfile() function.
  * It will make a temporary file under the root directory
@@ -379,6 +379,13 @@ exit_tmpfile:
 		archive_wstring_free(&temp_name);
 	return (fd);
 }
+#else
+int
+__archive_mktempx(const char *tmpdir, wchar_t *template)
+{
+    return -1;
+}
+#endif
 
 int
 __archive_mktemp(const char *tmpdir)
diff --git a/libarchive/archive_windows.c b/libarchive/archive_windows.c
index 624e2700..ede0269a 100644
--- a/libarchive/archive_windows.c
+++ b/libarchive/archive_windows.c
@@ -235,6 +235,7 @@ la_CreateFile(const char *path, DWORD dwDesiredAccess, DWORD dwShareMode,
 	wchar_t *wpath;
 	HANDLE handle;
 
+#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)
 	handle = CreateFileA(path, dwDesiredAccess, dwShareMode,
 	    lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes,
 	    hTemplateFile);
@@ -249,6 +250,20 @@ la_CreateFile(const char *path, DWORD dwDesiredAccess, DWORD dwShareMode,
 	    lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes,
 	    hTemplateFile);
 	free(wpath);
+#else /* !WINAPI_PARTITION_DESKTOP */
+	wpath = __la_win_permissive_name(path);
+	if (wpath == NULL)
+		return INVALID_HANDLE_VALUE;
+	CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+	createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+	createExParams.dwFileAttributes = dwFlagsAndAttributes & 0xFFFF;
+	createExParams.dwFileFlags = dwFlagsAndAttributes & 0xFFF00000;
+	createExParams.dwSecurityQosFlags = dwFlagsAndAttributes & 0x000F00000;
+	createExParams.lpSecurityAttributes = lpSecurityAttributes;
+	createExParams.hTemplateFile = hTemplateFile;
+	handle = CreateFile2(wpath, dwDesiredAccess, dwShareMode, dwCreationDisposition, &createExParams);
+	free(wpath);
+#endif /* !WINAPI_PARTITION_DESKTOP */
 	return (handle);
 }
 
@@ -320,7 +335,7 @@ __la_open(const char *path, int flags, ...)
 		}
 		if (attr & FILE_ATTRIBUTE_DIRECTORY) {
 			HANDLE handle;
-
+#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)
 			if (ws != NULL)
 				handle = CreateFileW(ws, 0, 0, NULL,
 				    OPEN_EXISTING,
@@ -333,6 +348,20 @@ __la_open(const char *path, int flags, ...)
 				    FILE_FLAG_BACKUP_SEMANTICS |
 				    FILE_ATTRIBUTE_READONLY,
 					NULL);
+#else /* !WINAPI_PARTITION_DESKTOP */
+			if (ws != NULL) {
+				CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+				createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+				createExParams.dwFileAttributes = FILE_ATTRIBUTE_READONLY;
+				createExParams.dwFileFlags = FILE_FLAG_BACKUP_SEMANTICS;
+				createExParams.dwSecurityQosFlags = 0;
+				createExParams.lpSecurityAttributes = NULL;
+				createExParams.hTemplateFile = NULL;
+				handle = CreateFile2(ws, 0, 0, OPEN_EXISTING, &createExParams);
+			}
+			else
+				handle = INVALID_HANDLE_VALUE;
+#endif /* !WINAPI_PARTITION_DESKTOP */
 			free(ws);
 			if (handle == INVALID_HANDLE_VALUE) {
 				la_dosmaperr(GetLastError());
diff --git a/libarchive/archive_windows.h b/libarchive/archive_windows.h
index 47b7cb8e..4aad8199 100644
--- a/libarchive/archive_windows.h
+++ b/libarchive/archive_windows.h
@@ -106,9 +106,11 @@
 #define	lseek		__la_lseek
 #define __LA_LSEEK_NEEDED
 #endif
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 #define	lstat		__la_stat
 #define	open		__la_open
 #define	read		__la_read
+#endif
 #if !defined(__BORLANDC__) && !defined(__WATCOMC__)
 #define setmode		_setmode
 #endif
@@ -276,8 +278,10 @@ extern int	 __la_stat(const char *path, struct stat *st);
 extern pid_t	 __la_waitpid(HANDLE child, int *status, int option);
 extern ssize_t	 __la_write(int fd, const void *buf, size_t nbytes);
 
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 #define _stat64i32(path, st)	__la_stat(path, st)
 #define _stat64(path, st)	__la_stat(path, st)
+#endif
 /* for status returned by la_waitpid */
 #define WIFEXITED(sts)		((sts & 0x100) == 0)
 #define WEXITSTATUS(sts)	(sts & 0x0FF)
diff --git a/libarchive/archive_write_disk_windows.c b/libarchive/archive_write_disk_windows.c
index 1b12a299..f90861b0 100644
--- a/libarchive/archive_write_disk_windows.c
+++ b/libarchive/archive_write_disk_windows.c
@@ -290,14 +290,31 @@ file_information(struct archive_write_disk *a, wchar_t *path,
 		(findData.dwReserved0 == IO_REPARSE_TAG_SYMLINK)))
 		flag |= FILE_FLAG_OPEN_REPARSE_POINT;
 
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+	CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+	createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+	createExParams.dwFileAttributes = 0;
+	createExParams.dwFileFlags = flag;
+	createExParams.dwSecurityQosFlags = 0;
+	createExParams.lpSecurityAttributes = NULL;
+	createExParams.hTemplateFile = NULL;
+	h = CreateFile2(a->name, 0, 0,
+		OPEN_EXISTING, &createExParams);
+#else
 	h = CreateFileW(a->name, 0, 0, NULL,
 	    OPEN_EXISTING, flag, NULL);
+#endif
 	if (h == INVALID_HANDLE_VALUE &&
 	    GetLastError() == ERROR_INVALID_NAME) {
 		wchar_t *full;
 		full = __la_win_permissive_name_w(path);
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+		h = CreateFile2(full, 0, 0,
+			OPEN_EXISTING, &createExParams);
+#else
 		h = CreateFileW(full, 0, 0, NULL,
 		    OPEN_EXISTING, flag, NULL);
+#endif
 		free(full);
 	}
 	if (h == INVALID_HANDLE_VALUE) {
@@ -559,6 +576,7 @@ la_mktemp(struct archive_write_disk *a)
 	return (fd);
 }
 
+#if _WIN32_WINNT < _WIN32_WINNT_VISTA
 static void *
 la_GetFunctionKernel32(const char *name)
 {
@@ -574,6 +592,7 @@ la_GetFunctionKernel32(const char *name)
 	}
 	return (void *)GetProcAddress(lib, name);
 }
+#endif
 
 static int
 la_CreateHardLinkW(wchar_t *linkname, wchar_t *target)
@@ -582,10 +601,19 @@ la_CreateHardLinkW(wchar_t *linkname, wchar_t *target)
 	static int set;
 	BOOL ret;
 
+#if _WIN32_WINNT < _WIN32_WINNT_XP
+/* CreateHardLinkW is available since XP and always loaded */
 	if (!set) {
 		set = 1;
 		f = la_GetFunctionKernel32("CreateHardLinkW");
 	}
+#else
+# if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+	f = CreateHardLinkW;
+# else
+	f = NULL;
+# endif
+#endif
 	if (!f) {
 		errno = ENOTSUP;
 		return (0);
@@ -632,10 +660,19 @@ la_CreateSymbolicLinkW(const wchar_t *linkname, const wchar_t *target,
 	DWORD newflags = 0;
 	BOOL ret = 0;
 
+#if _WIN32_WINNT < _WIN32_WINNT_VISTA
+/* CreateSymbolicLinkW is available since Vista and always loaded */
 	if (!set) {
 		set = 1;
 		f = la_GetFunctionKernel32("CreateSymbolicLinkW");
 	}
+#else
+# if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
+	f = CreateSymbolicLinkW;
+# else
+	f = NULL;
+# endif
+#endif
 	if (!f)
 		return (0);
 
@@ -1718,8 +1755,20 @@ create_filesystem_object(struct archive_write_disk *a)
 			a->todo = 0;
 			a->deferred = 0;
 		} else if (r == 0 && a->filesize > 0) {
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+			CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+			createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+			createExParams.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
+			createExParams.dwFileFlags = 0;
+			createExParams.dwSecurityQosFlags = 0;
+			createExParams.lpSecurityAttributes = NULL;
+			createExParams.hTemplateFile = NULL;
+			a->fh = CreateFile2(namefull, GENERIC_WRITE, 0,
+			    TRUNCATE_EXISTING, &createExParams);
+#else
 			a->fh = CreateFileW(namefull, GENERIC_WRITE, 0, NULL,
 			    TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+#endif
 			if (a->fh == INVALID_HANDLE_VALUE) {
 				la_dosmaperr(GetLastError());
 				r = errno;
@@ -1782,14 +1831,31 @@ create_filesystem_object(struct archive_write_disk *a)
 		a->tmpname = NULL;
 		fullname = a->name;
 		/* O_WRONLY | O_CREAT | O_EXCL */
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+		CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+		createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+		createExParams.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
+		createExParams.dwFileFlags = 0;
+		createExParams.dwSecurityQosFlags = 0;
+		createExParams.lpSecurityAttributes = NULL;
+		createExParams.hTemplateFile = NULL;
+		a->fh = CreateFile2(fullname, GENERIC_WRITE, 0,
+		    CREATE_NEW, &createExParams);
+#else
 		a->fh = CreateFileW(fullname, GENERIC_WRITE, 0, NULL,
 		    CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
+#endif
 		if (a->fh == INVALID_HANDLE_VALUE &&
 		    GetLastError() == ERROR_INVALID_NAME &&
 		    fullname == a->name) {
 			fullname = __la_win_permissive_name_w(a->name);
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+			a->fh = CreateFile2(fullname, GENERIC_WRITE, 0,
+			    CREATE_NEW, &createExParams);
+#else
 			a->fh = CreateFileW(fullname, GENERIC_WRITE, 0, NULL,
 			    CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
+#endif
 		}
 		if (a->fh == INVALID_HANDLE_VALUE) {
 			if (GetLastError() == ERROR_ACCESS_DENIED) {
@@ -2551,8 +2617,20 @@ set_times(struct archive_write_disk *a,
 		ws = __la_win_permissive_name_w(name);
 		if (ws == NULL)
 			goto settimes_failed;
+# if _WIN32_WINNT >= 0x0602 /* _WIN32_WINNT_WIN8 */
+		CREATEFILE2_EXTENDED_PARAMETERS createExParams;
+		createExParams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+		createExParams.dwFileAttributes = 0;
+		createExParams.dwFileFlags = FILE_FLAG_BACKUP_SEMANTICS;
+		createExParams.dwSecurityQosFlags = 0;
+		createExParams.lpSecurityAttributes = NULL;
+		createExParams.hTemplateFile = NULL;
+		hw = CreateFile2(ws, FILE_WRITE_ATTRIBUTES, 0,
+		    OPEN_EXISTING, &createExParams);
+#else
 		hw = CreateFileW(ws, FILE_WRITE_ATTRIBUTES,
 		    0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
+#endif
 		free(ws);
 		if (hw == INVALID_HANDLE_VALUE)
 			goto settimes_failed;
diff --git a/libarchive/filter_fork_windows.c b/libarchive/filter_fork_windows.c
index 0b963975..fc9c0f55 100644
--- a/libarchive/filter_fork_windows.c
+++ b/libarchive/filter_fork_windows.c
@@ -31,6 +31,13 @@
 
 #include "filter_fork.h"
 
+#if !WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)
+int
+__archive_create_child(const char *cmd, int *child_stdin, int *child_stdout, HANDLE *out_child)
+{
+	return ARCHIVE_FAILED;
+}
+#else /* WINAPI_PARTITION_DESKTOP */
 /* There are some editions of Windows ("nano server," for example) that
  * do not host user32.dll. If we want to keep running on those editions,
  * we need to delay-load WaitForInputIdle. */
@@ -224,6 +231,7 @@ fail:
 	__archive_cmdline_free(acmd);
 	return ARCHIVE_FAILED;
 }
+#endif /* WINAPI_PARTITION_DESKTOP */
 
 void
 __archive_check_child(int in, int out)
-- 
2.37.3.windows.1

